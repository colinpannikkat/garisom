#ifndef XYLEM_H
#define XYLEM_H

#include "04Component.h"
#include "02Soils.h"
#include "05Root.h"
#include "06Stem.h"
#include "07Leaf.h"

/*

    Each layer layer contains a root element connected to a rhizosphere component.

    There are five horizontal layers.

    Biomass_fraction is determined as follows:

    \Beta = 1 - \beta^d, where \Beta is fraction of biomass above depth d in cm, 
    and 0 < \beta < 1. Max root depth set at \Beta = 0.995.

*/

struct SoilLayer {
    RootComponent root;
    RhizosphereComponent rhizosphere;
    double  biomass_fraction = 0.0,
            kkmax = 0.0,
            vert_distance = 0.0,
            layer_depth = 0.0,
            depth = 0.0,
            radius = 0.0,
            length = 0.0,
            swclimit = 0.0,
            soilredist = 0.0,
            flow = 0.0,
            predawn_pressure = 0.0;
    bool    cavitated = false;
    bool    cavitated_t = false;
    std::string  failure;
    std::string  failure_t;
};

class XylemComponent {

    public:

        XylemComponent() {};
        ~XylemComponent();
        
        LeafComponent leaf;
        StemComponent stem;
        std::vector<SoilLayer*> soils;
        int num_layers;

        double e_p[CURVE_MAX] = {0}; // whole xylem transpiration curve
        double k[CURVE_MAX] = {0}; // whole xylem conductance curve
        double root_pressure[CURVE_MAX] = {0}; // composite root pressure
        
        /* Used for something! */
        double rough = 0,
               zdispl = 0,
               zh = 0;

        void cleanParameters();

        /*

            If only one soil layer, all components are in series and the E_i
            is identical for all components and equal to canopy E. Then we can
            just use individual integral transform for each component.
        
            If root and rhizosphere components are partitioned into N parallel 
            paths that drain given a known P_soil. There are then N + 1 unknown 
            pressures:

            E_{i(rhizosphere)} - E_{i(root)} = 0, root surface pressure
            \sum{E_{i(root)}} - E = 0, root crown pressure

            This is solved via multidimensional Newton Rhaphson.

            E_i is determined via Component:flow_rate(). E is specified. Stem
            and leaf pressures are obtained from Component:flow_rate() and
            supply function generated by incrementing E from zero.

            Inputs:
                - 

            Outputs:
                - 
        
        */
        double& calc_pressure();

        /*

            After every time step, bulk soil water content and boundary 
            conditions must be recalculated for every soil layer. Net flow from 
            the previous time step is added to the old water content to obtain
            new water content. Net flow is the sum of:

                1. Flow across rhizosphere. This is calculated along E(P_c)
                   function
                2. Rain or irrigation in previous time step
                3. Soil evaporation
                4. Redistribution between layers, estimated from integral
                   transform of van Genuchten K(P_s) function.

        */
        void calc_net_flow();

        void calc_flow(const double &p_inc, const double &k_min);

        // function that accounts for xylem cavitation fatigue
        double fatigue(double &b_wb, const double &sapwood_t, const double &conduit_d, const double &max_plc_x);

        void printCurveToFile(const double &p_inc, const double &p_crit, const std::string &filename) const {
            std::ofstream outFile(filename);
            if (!outFile) {
            std::cerr << "Error opening file: " << filename << std::endl;
            return;
            }

            outFile << "p_inc,E(P)" << std::endl;
            for (int i = 0; p_inc * i <= p_crit; ++i) {
            outFile << p_inc * i << "," << e_p[i] << std::endl;
            }

            outFile.close();
        }
};

#endif